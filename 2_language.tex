\chapter{Dual programming language design}\label{chap:lang}
This chapter describes the text representation of Dual, which is the basis for the executable representation for the interpreter (the syntax tree) and for the block-based visual representation discussed in the following chapters.

The evolution of programming languages is a gradual process. And so is the process of designing a single language. The approach that I found effective was iterative refinement, addition, testing, and sometimes subtraction of features. In practice this translates to intermediate designs and implementations being rearranged into new forms, with some discarded. I did not arrive at something that I could call the final form of the language, so a lot of the features described here are subject to change and improvement. I intend to work on this project further beyond the scope of this thesis.

The language was not originally intended to be a Lisp-like language or clone thereof, but throughout the research I ended up learning a lot about Lisp, sometimes by reinventing parts of this language. A somewhat philosophical interpretation of this would be that Lisp is built on fundamental principles that are (re)discoverable rather than invented.

In this and the following chapters I cover a lot of ``design surface'', only delving deep into some features that are relevant to core ideas that I wanted to convey in this thesis.

\section{Syntax and grammar}
Among the main design goals for the prototype of the language were simplicity
and clarity. I wanted a language that is easy to parse and transform to a
different representation. This restriction suggests that the syntax should be as
minimal as possible.  

I choose Lisp's syntax as the starting point. It is indeed almost as simple as one could imagine. But because of its almost complete uniformity it is often criticized. Some of the major criticisms are:
\begin{itemize}
    \item In general it is hard to teach, because complex code gets easily confusing\cite{wadler_critique}.
    \item The more nested the syntax tree, the harder it is to keep track of and
      balance parentheses; there tends to be a lot of closing parentheses next
      to each other in the source\cite{c2_parentheses}.
\end{itemize}

I made a few simple adjustments to the syntax in order to address these concerns, at least to some degree. These modifications do not significantly increase the complexity of a parser, but may considerably improve the syntax in terms of ease of use and readability for a human.

\subsection{Basic syntax}\label{sub:basic_syntax}
Below I present the definition of Dual's grammar in left-recursion-free \acrlong{bnf}. It is included here only for the sake of formality. I believe that for such a simple grammar BNF introduces more noise and is unnecessarily more complex than a textual description, possibly with the help of regular expressions or simply verbatim parser source code. For these reasons any extensions to this basic grammar will later on be introduced in these ways.

This is the \acrshort{bnf} definition, a bit verbose for clarity:
\begin{lstlisting}
<expression> ::= <word> | <call>
<call> ::= <operator> <argument-list>
<operator> ::= <word> <argument-lists>
<argument-list> ::= "[" <arguments> "]"
<word> ::= /[^\s\[\]]+/
<argument-lists> ::= <argument-list> <argument-lists> | ""
<arguments> ::= <expression> <arguments> | ""
\end{lstlisting}

\acrshort{bnf} here is extended with the addition of a regular expression (between \texttt{/} delimiters) in the definition of \texttt{<word>}. The regular expression can be read as ``any character which is not white space,
\texttt{[} or \texttt{]}''. This means that aside from white space, which acts as
expression separator there are only two special characters that the parser has to worry about -- the square brackets.

The above grammar definition is obviously very similar to Lisp's BNF description\cite{lisp_bnf_1, lisp_bnf_2}.

The following expression in Lisp:
\begin{lstlisting}
(+ 2 (expt 3 5))
\end{lstlisting}

has an equivalent expression in Dual:
\begin{lstlisting}
+[2 expt[3 5]]
\end{lstlisting}

Comparing these, we may observe that in Dual:
\begin{itemize}
    \item The primary bracketing characters are square brackets (\texttt{[]})
    instead of parentheses. The reason for that design choice is that these
    are easier to type than parentheses or curly brackets (as they do not
    require holding the shift key), which matters considering the ubiquity of
    these characters in the source code.
    \item Expression's operator name is written \textit{before} the opening bracket that precedes the list of arguments, as in \texttt{operator[argument-1 argument-2 ... argument-n]}.
\end{itemize}

Other than these two differences, Dual's notation is equivalent to S-expressions. Its advantages are:
\begin{itemize}
    \item It is easier to parse by a human. Operators are clearer distinguished from operands. This is arguably because this notation is more familiar, bearing a similarity to the general mathematical notation (as in \texttt{f(x)}) and the most popular programming language syntax -- the C-like syntax\footnote{11 out of the
        top 20 languages as of June 2016\cite{tiobe} have C-based syntax (by this classification: \cite{c_family_list_wikipedia}). If
        we extend the syntax family to Algol-like, its virtually 20 out of 20 --
        \cite{pl_genealogy}. There are no languages with Lisp-based syntax among the most popular ones.}
    \item If an expression has another expression as its operator, it is written
      as \texttt{op[args-1][args-2]}, which reduces the amount of nesting and
      thus the amount of identical bracketing characters appearing next to each other in the source code. Compare the equivalent S-expression: \texttt{((op args-1) args-2)}; and with multiple levels:
      \texttt{op[args-1][args-2][args-3][args-4]} vs \texttt{((((op args-1)
        args-2) args-3) args-4)}.
\end{itemize}

An interesting property of this syntax that, depending on the context, could be
classified as an advantage, disadvantage or neither is that the sequence of
characters \texttt{[[} is not legal, whereas in Lisp the analogous sequence \texttt{((} is.

Alas, this simple notation doesn't do away with a lot of other problems inherent
in all minimal syntaxes, related to their homogenity. Later in this chapter I will introduce extensions and syntax sugar, which make the notation a little bit more diverse. Keep in mind that every special character that is introduced, is taken away from the set of possible \texttt{<word>}-characters, which implies that the regular expression for \texttt{<word>} is changed accordingly.

\section{Comments}\label{sub:comments}
Comments are a basic and indispensable syntax feature of any programming language. I chose to include a comment syntax similar to the one found in Ada, Haskell or Lua:
\begin{lstlisting}
-- a comment that extends until the end of the line

-- an expression that computes square root of 81:
sqrt[81]

--[
    this is a multiline comment
    --[
        multiline comments can be nested
        
        as long as [ and ] are balanced, anything can be nested within
        multiline comments
        
        for example:
        --[
            this is a comment that includes a piece of code:
            *[7 7]
            
            which would evaluate to 49
        ]
    ]
]
\end{lstlisting}

\section{Numbers}
Numbers in the language are represented as JavaScript numbers. This means that
there's only one number type -- 64-bit floating point\footnote{Defined by the
  ISO/IEC/IEEE 60559:2011 (IEEE 754) standard:
  \cite{60559_2011, js_numbers}}. They are implemented as follows:
\begin{itemize}
    \item When a word is tokenized by the parser, it is converted to a
      JavaScript number with a Number type constructor, which returns either the
      corresponding value (if the word is parsable to a number) or the value
      \texttt{NaN}. In the former case, the numerical value is stored in the
      appropriate syntax tree node, as its \texttt{value} property.
    \item Upon evaluation, a syntax tree node is checked for the \texttt{value}
      property. If it has one it is given as the result of the evaluation.
    \item The fact that a number is stored as a syntax tree node, which contains
      the its string representation and its raw value, both obtained from the
      source code during parsing means that conversion from a number literal to
      string is zero-cost, which could be useful for optimization.
\end{itemize}

Thus all of the following JavaScript number literals are valid in Dual:
\begin{lstlisting}
1
357
3.14
0x11 // hexadecimal
0b11 // binary
0o11 // octal
5e-2 // exponential notation
\end{lstlisting}

\section{Escape character}
An escape character \texttt{\textbackslash} is introduced. It allows special characters to be included in variable names.

For example:
\begin{lstlisting}
word\ with\ spaces\ and\ braces\[\]
\end{lstlisting}
would be a single valid word and could be used as an identifier for a variable.

\section{Strings}
String values are introduced in Dual as follows:
\begin{lstlisting}
'[A quick brown fox jumps over the lazy dog]
\end{lstlisting}

\texttt{'} is a special operator that produces a string value. It takes any number of arguments, which must be valid expressions.

Strings support variable substitution (also known as string interpolation\cite{string_interpolation_wikipedia}). Assuming we have a variable \texttt{animal-0} with the string value \texttt{"bear"} and another variable \texttt{animal-1} with the string value \texttt{"duck"}, this string:
\begin{lstlisting}
'[A quick brown {animal-0} jumps over the lazy {animal-1}]
\end{lstlisting}

would evaluate to:
\begin{lstlisting}
"A quick brown bear jumps over the lazy duck"
\end{lstlisting}

Special characters inside string can be escaped with the escape character \texttt{\textbackslash}. Note that balanced square brackets that are part of syntactically valid Dual expression do not have to be escaped.

The implementation of strings is explained in detail in Section \ref{sec:est}. String interpolation is explained in Section \ref{sec:sub}.

\section{Basic primitives and built-ins}\label{sec:primitives}
This section enumerates and briefly describes Dual's basic primitives and built-in functions and values.

The items in Sections \ref{sub:fun} and \ref{sub:primitives} are structured as follows:
\begin{itemize}
    \item \texttt{<<name>> [<<arguments>>]}
    
    <<description>>
\end{itemize}

Where \texttt{<<name>>} is the name of the function/primitive and
\texttt{<<arguments>>} are either the names that describe the arguments of the
function/primitive or its arity. That is, the number of arguments that the
function/primitive is defined for. This can be a fixed value (e.g
\texttt{1}), a fixed range of values (e.g. \texttt{0..3}) or a range of
values without an upper bound (e.g. \texttt{0..*}, which means 0 or more). An argument name can optionally contain a colon character \texttt{:}, which is followed by the type that the argument is expected to have.

<<description>> is a brief description of the function/primitive.

\subsection{Functions}\label{sub:fun}
The following basic functions are defined in the language:
\begin{itemize}
    \item \texttt{list [0..*]}
    
    Returns a JavaScript \texttt{Array}\cite{mdn_array}, which contains the values of its arguments.
    
    \item \texttt{\$ [0..*]}
    
    An alias for \texttt{list}.
    
    \item \texttt{apply [f args]}
    
    Works like Lisp's \texttt{apply}: it takes a function and a list of arguments and returns the result of applying the function to the arguments.
    
    \item \texttt{log [0..*]}
    
    Wraps JavaScript's \texttt{console.log} method\cite{mdn_log}. It outputs the values of its arguments to JavaScript's standard output -- web browser's console.
    
    \item \texttt{typeof [arg]}
    
    Wraps JavaScript's \texttt{typeof} operator. ``[R]eturns a string indicating the type of the unevaluated operand.''\cite{mdn_typeof}
    
    \item \texttt{or [a b]} and \texttt{and [a b]}
    
    The basic logical operators -- analogous to \texttt{||} and \texttt{\&\&} in JavaScript.
    
    \item \texttt{any [0..*]} and \texttt{all [0..*]}
    
    Like the above, but accept variable number of arguments. These return either \texttt{true} or \texttt{false}.
    
    \item \texttt{not [arg]} 
    
    The logical negation operator (\texttt{!}).
        
    \item \texttt{mod [arg]}
    
    The modulus (\texttt{\%}) operator.
    
    \item \texttt{-\# [arg]} 
    
    The unary minus operator. It negates its argument.
    
    \item \texttt{sum [0..*]} and \texttt{mul [0..*]}
    
    Perform summation and product operations on any number of arguments.
    \item \texttt{to-int [arg:number]} 
    
    Converts its argument to an integer value, by truncating the decimal part.
    
    \item \texttt{strlen [str:string]}
    
    Returns the length of \texttt{str}.
    \item \texttt{str@ [str:string n:integer]} 
    
    Returns the \texttt{n}th character of \texttt{str}.
\end{itemize}

Moreover, all basic binary inequality operators \texttt{<, >, <=, >=} as well as all basic binary arithmetic operators \texttt{+, -, *, /} are supported. Comparison operators: \texttt{=} and \texttt{<>} are equivalent to JavaScript's \texttt{===} and \texttt{!==}, which means they perform strict comparison, without implicit type conversion\cite[Section~Equality operators]{mdn_comparison_operators}.

\subsection{Language primitives}\label{sub:primitives}
The Dual language supports the following primitives:
\begin{itemize}
    \item \texttt{bind [name value]}
    
    Evaluates its second argument and binds this value to the name of the first
    argument. This name is bound within the current scope. This is a basic
    construct for defining variables, like \texttt{var} or \texttt{define} in
    other languages. Significant semantics here are that new scopes are
    introduced by function bodies, macro bodies and match expression bodies. The
    primitive also supports pattern matching to deconstruct the value and bind
    its components to possibly several variables. In that regard it works a lot
    like JavaScript's destructuring
    assignment\cite{mdn_destructuring}
    or similar features in other languages, such as Perl or Python. This
    primitive can be used only for binding names that don't exist in the scope
    at the point of its invocation. There are other constructs for mutating and
    modifying existing variables. There is no
    hoisting\cite[Section~var hoisting]{mdn_var},
    as definitions are processed in order in which they appear in code.
    
    For example:
\begin{lstlisting}
bind [greeting '[Hello]]
\end{lstlisting}
    
    \item \texttt{if [condition consequent alternative]}
    
    This primitive serves as a basic conditional evaluation construct. Its
    semantics are like those of the analogous construct in Lisp. It accepts 3
    arguments: first the \texttt{condition} expression, then the
    \texttt{consequent}, that is, the expression to be evaluated if the value of
    the condition is \textit{not false} (note that this is a strict rule; any
    other value than \texttt{false} is interpreted as \texttt{true}; every
    conditional construct in the language follows this rule). The third
    argument, the \texttt{alternative} is the expression that is evaluated
    otherwise.
    \item \texttt{do [0..*]}
        
    Evaluates its arguments in order and returns the value of the last argument. Fulfils the role of a block of expressions.
    
    For example:
\begin{lstlisting}
if [<[a 2] do [
    bind [b -[2 a]]
    log['[difference b:] b]
] do [
    bind [c -[a 2]]
    log ['[difference c:] c]
]]
\end{lstlisting}
    
    \item \texttt{while [condition body]}
    
    A basic loop construct. If \texttt{condition} is equivalent to \textit{not
        false}, evaluates \texttt{body}. Repeats these steps until
    \texttt{condition} evaluates to \texttt{false}. Returns the value of the
    last evaluation of \texttt{body} or \texttt{false} if the body was not
    evaluated.
    
    \item \texttt{mutate [name value]}
    
    If a variable identified by \texttt{name} is defined within the current
    scope or any outer scope, changes (mutates) its value, so it now refers to
    the result of evaluating the \texttt{value} argument. The scopes are
    searched from the innermost to the outermost, in order. If the \texttt{name}
    argument doesn't identify any variable, an error is thrown. Returns the
    scope (environment), in which the primitive was evaluated.
    
    \item \texttt{dict [0..*]}
    
    Creates and returns a JavaScript object. It takes an even number of arguments. Arguments are considered in twos, as key-value pairs. These pairs determine properties for the new objects. Keys, which must be words, are property names and their corresponding values, which can be arbitrary expressions, are the values of these properties.
    
    For example:
\begin{lstlisting}
-- creates an object with four properties and assigns it
-- to variable `car`:
bind [car dict [
    id 0
    brand '[Ford]
    model '[Mustang]
    year 1969 
]]
\end{lstlisting}
    
    \item \texttt{assign [2..*]}
    
    A wrapper for JavaScript's Object.assign()\cite{mdn_assign}. It copies the values of all properties from one or more source objects to a target object. Returns the target object. The first argument is the target object, the following arguments are the source objects.
    
    \item \texttt{code' [arg]}
    
    Returns its argument without evaluating it. Used in macros, which return unevaluated code, which is substituted in the syntax tree and only then evaluated.
    
    \item \texttt{macro [1..*]}
    
    Returns a macro value. The last argument is the macro's body. The preceding arguments are the patterns for the macro's arguments. See Sections \ref{sec:pat} and \ref{sec:mac} for details.
    
    \item \texttt{of [1..*]}
    
    Returns a function value. The last argument is the function's body. The preceding arguments are the patterns for the macro's arguments. See Section \ref{sec:pat} for details.
    
    \item \texttt{of~ [2..*]} 
    
    Returns a function value. Treats its penultimate argument as the function's body and all the preceding arguments as patterns for the function's arguments. See Section \ref{sec:pat} for details.
    
    The last argument is used when the function is called and the values supplied as arguments do not match the patterns. If the argument is a function, it will be called with the same values as arguments and if it is a value it will be returned.
    
    This enables chaining functions together like so:
\begin{lstlisting}

bind [f
    of~ [a b c log['[called with three arguments]]
        of~ [a b log['[called with two arguments]]
            of~ [a log['[called with one argument]]
                log['[called with zero or more than three arguments]]
            ]
        ]
    ]
]

-- will log "called with two arguments":
f[3 2]
\end{lstlisting}
    
    \item \texttt{procedure [body]}
    
    Returns a function value. Its only argument is the function's body.
    
    \item \texttt{match [2..*]}
    
    Performs pattern matching. Its first argument is an expression to be matched. The following arguments are two-element lists, where the first element is the pattern to be matched and the second the expression to be evaluated if it matches. See Section \ref{sub:match} for details.
        
    \item \texttt{cond [1..*]}
    
    It works like a nested \texttt{if-else}s and similarly to Lisp's \texttt{cond}\cite[Section~5.3, Macro~COND]{common_lisp_hyperspec}. Its arguments are two-element lists, where the first element is a condition that should evaluate to a boolean value and the second is the expression to be evaluated if it the condition is true. It evaluates at most one expression: the one that has a true condition. Conditions are checked in order.
    
    \item \texttt{. [2..*]}
    
    Property accessor. Essentially works like JavaScript's \texttt{.} operator\cite{mdn_dot}:
    
    For example:
\begin{lstlisting}
.[window Date now][]
\end{lstlisting}
    
    translates to JavaScript as:
\begin{lstlisting}
window.Date.now();
\end{lstlisting}
    
    If a property cannot be accessed, an error is thrown.
    
    \item \texttt{: [3..*]}
    
    Works symmetrically to \texttt{.} -- it sets a property to a value specified by its last argument.
    
    For example:
\begin{lstlisting}
:[game-state hero ammo 5]
\end{lstlisting}
    
    translates to JavaScript as:
\begin{lstlisting}
gameState.hero.ammo = 5;
\end{lstlisting}
       
    If a property cannot be accessed, an error is thrown.
    
    \item \texttt{@ [arg]}
    
    Identity operator. Returns the value of its argument.
    
    \item \texttt{async [1..*]}
    
    Its first argument should be an asynchronous JavaScript function, such as \texttt{requestAnimationFrame}\cite{mdn_requestanimationframe}. It applies this function to its remaining arguments.
\end{itemize}

\subsection{Values}
The following values are also defined:
\begin{itemize}
    \item \texttt{true} and \texttt{false}
    
    Evaluate to their respective boolean values. \texttt{\_} is an alias for \texttt{true} when used outside of pattern-matching. This enables a convenient compatibility between \texttt{match} and \texttt{cond}: if we're matching a single value and want to have a default case, then \texttt{\_} is used to match any value. Similarly, if \texttt{\_} is given as a condition in the last alternative of \texttt{cond}, it will evaluate to \texttt{true} and work as the default case.
    
    \item \texttt{undefined}
    
    Evaluates to JavaScript's \texttt{undefined} value. It is a primitive type that is used by the language to mark values that have not been assigned a value. Also, functions that do not explicitly return a value, return \texttt{undefined}\cite{mdn_undefined}.
    
    \item \texttt{window} 
    
    Provides access to JavaScript's global \texttt{window} object\cite{mdn_window}.
\end{itemize}

\section{Enhanced Syntax Tree}\label{sec:est}
In order to enable full mapping between any number of program representations at the syntax-level, a modification of an \acrshort{ast} was designed as a data structure representation of Dual's syntax. I call this structure the \acrlong{est} (\acrshort{est}). This crucial element in the language's design is described in this section.

The primary representation of a program in Dual is the EST. Although itself not directly editable, it can contain references to any number of editable representations, such as the text and visual ones.

These other representations contain back-references to the EST. Thanks to this, a change to any of the representations can be propagated to every other representation.

Every representation must come with:
\begin{itemize}
    \item A way to translate it to an EST.
    \item A way to generate it for a given EST.
    \item A way or ways to manipulate it.
\end{itemize}

While translating, generating and manipulating, it must be ensured that each entity of the representation has a bidirectional association to a corresponding EST node.

For example, for text representation:
\begin{itemize}
    \item Translation to EST is done with a parser.
    \item Generation from EST is done with an unparser\cite{unparser_wikipedia}.
    \item Manipulation is done with a text editor.
\end{itemize}

To ensure that the associations are kept, there must be objects that represent ``text fragments''. These objects then must contain references to corresponding EST nodes and vice versa.

White space characters and comments have no semantic significance, unless serving as separators could be considered one. After parsing, bracketing characters also serve no purpose and can be safely discarded, without influencing the meaning of the program. This is indeed done when constructing an \acrshort{ast} from text in most programming languages.

In case of Dual though, no characters are discarded. Instead, white space, comments, brackets and any other characters are included in the EST, connected to appropriate nodes. Storing all characters in the EST means that the entirety of text representation, in structural form, is accessible straight from the syntax tree. This allows an unparser to recreate it \textit{exactly}.

Such design greatly simplifies the implementation of and integrates with
the language features such as:
\begin{itemize}
    \item Automatic indentation. The \acrshort{est} contains all white space. If a new node is inserted into it, it can be initialized with white space of its siblings and/or ancestors, etc..
    \item Documentation comments. Comments can easily be associated with
      corresponding code blocks (EST nodes), which can be useful for
      automatically generating documentation in any format.
    \item Any expression can be unparsed to its original form straight from
      syntax tree, which can be used for debugging. For example, if a Dual program is built by manipulating visual representation entirely without the use of text and an error occurs while interpreting it, a single EST node -- the one that contains the erroneous expression -- can be unparsed and presented by the debugger in editable form. This may allow the user to fix the error quicker than manipulating blocks, without the need to unparse the entire program.
  \item Any expression can be stringified (serialized) on-the-fly and
        this string can be used as a value in the program or stored in a file.
\end{itemize}

\subsection{Structural representation of strings}\label{sub:str}
The last feature from the above list provides an interesting way of implementing strings in the language. Instead as streams of characters, they could be kept in structural form -- as syntax trees. In combination with pattern matching this enables language-native structural manipulation of strings\footnote{See: \cite{wolfram_string_patterns} and \cite[Section~Pattern matching and strings]{pattern_matching_wikipedia} for similar concepts.}. For example we could write:
\begin{lstlisting}
bind [str '[A quick brown fox jumps over the lazy dog]]
            
bind [words [_ _ third-word {rest}] str]

bind [characters [_ _ third-letter {rest}] third-word]

-- logs "o" to the console:
log [third-letter]
\end{lstlisting}
    
Where \texttt{words} deconstructs a string into individual words and binds these
words to identifiers provided as its arguments. \texttt{characters} performs
an analogous operation on the character-level. The notation
\texttt{\{rest\}} matches zero or more arguments (see Section \ref{sub:rest} for
details). \texttt{log} outputs the values of its arguments to the JavaScript
console.

A downside here is that such representation of strings is not very efficient. A simple optimization would be to keep the raw form of the string (a stream of characters) as a value in the corresponding syntax tree node. So the raw representation is extended instead of replaced. Having these two forms alongside each other would enable the programmer to use the familiar string
manipulation methods as well as structural manipulation without significant performance impact.

\section{Syntax sugar for function invocations}
In order to reduce the amount of \textit{closing} brackets appearing next to
each other in program's text, two additional simple notations were
introduced. The first is addition of the pipe special character
(\texttt{|}). It is used for single-argument functions.

If a function is invoked with only one argument, we can omit the closing bracket \texttt{]} and replace the opening bracket \texttt{[} with \texttt{|}. \texttt{|} can be viewed as a right-associative ``invocation operator''. For example:
\begin{lstlisting}
foo | bar | baz
\end{lstlisting}
is equivalent to:
\begin{lstlisting}
foo [bar [baz]]
\end{lstlisting}

The parser produces equivalent syntax trees for the above cases.

Below I present more examples to illustrate the utility of this syntax. Note that \texttt{<=>} symbol used in comments means ``equivalent to'':
\begin{lstlisting}
-- compute factorial of 32:
-- <=> factorial[32]
factorial|32

-- find 9th Fibonacci number:
-- <=> fibonacci[9]
fibonacci|9

-- compute sine of pi:
-- <=> sin[pi]
sin|pi

-- compute cosine of the number that is
-- the result of multiplication of pi and 5!:
-- <=> cos[*[pi factorial[5]]]
cos|*[pi factorial|5]

-- convert 33.2 to an integer (truncate .2):
-- <=> to-int[33.2]
to-int|33.2

-- construct a list with one item,
-- which is a string "hello":
-- <=> list['[hello]]
list|'|hello
\end{lstlisting}

Another special character (\texttt{!}) was introduced for analogous use in
zero-argument expressions (procedures):
\begin{lstlisting}
-- invoke a procedure that changes
-- some state variables in its outer scope:
-- <=> set-initial-state[]
set-initial-state!

-- sum two random numbers:
-- <=> +[random[] random[]]
+[random! random!]

-- bind a value returned by an immediately
-- invoked procedure to an identifier:
-- <=> bind [forty-two procedure [42][]]
bind [forty-two procedure [42]!]

-- evaluates to 42:
forty-two
\end{lstlisting}

\section{Pattern matching}\label{sec:pat}
A simple, yet powerful pattern-matching facilities were added to the language, which further extend its expressive power.

Pattern matching works with bindings, functions, \texttt{match} primitive and macros.

The pattern matching works in a way similar to most other languages that support
this feature (e.g. ML family). The general rules are:
\begin{itemize}
    \item A literal (strings or numbers are supported) value matches itself:
\begin{lstlisting}
-- computes factorial of a number:
bind [factorial
    of~ [0 1
    of~ [n *[n factorial[-[n 1]]]]]
]

-- logs `120`:
log [factorial|5]
\end{lstlisting}

    \item An identifier (word) matches any value, which is then bound to the
      identifier:
\begin{lstlisting}
bind [simple-print of [x log|x]]

-- logs `3`:
simple-print[3]
\end{lstlisting}

    \item A wildcard pattern (\texttt{\_}) matches any value, but does not bind:
\begin{lstlisting}
-- returns its third argument, discards the rest:
bind [get-third of [_ _ x x]]

-- logs `3`:
log [get-third[1 2 3]]
\end{lstlisting}
    As such it can be useful for discarding some values, depending on other
    values or extracting some values from a structure (see next point).
\end{itemize}

Also the following expression-patterns are supported:
\begin{itemize}
    \item \texttt{list} or \texttt{\$} is used to destructure lists:
\begin{lstlisting}
bind [$[_ _ third-element] $[0 1 2]]

-- logs `3`:
log [third-element]

-- it works for arbitrarily nested lists as well:
bind [
    $[  _ $[  _  pick  _   _]   _] 
    $['|a $['|b  '|c '|d '|e] '|f]
]

-- logs `c`:
log [pick]
\end{lstlisting}

    \item Comparison operators (\texttt{= < <= >= <>}) match if a value
      passes the comparison; it can be viewed as a shorthand notation for
      simple
      guards\cite[Chapter~Pattern Matching Basics, Section Using Guards within Patterns]{f_sharp_wikibooks}:
\begin{lstlisting}
-- returns the sign of a number
-- note: `-#` is the unary `-` operator:
bind [sign
    of [=|0 0
    of [<|0 -#|1
    of [>|0 1]]]
]

-- logs `-1`:
log [sign|-77]
\end{lstlisting}
\end{itemize}

Other pattern-expressions are not supported and using them will result in a mismatch.

\subsection{Destructuring}
Pattern matching works with bindings, the language allows destructuring assignments and definitions\cite{mdn_destructuring}. An example of a such definition would be:
\begin{lstlisting}
bind [
    $[a b $[c d]]
    $[1 2 $[3 4]]
]

bind [
    $[  _   x   y  {   rest   }]
    $['|a '|b '|c  '|d '|e  '|f]
]

-- logs `1 2 3 4`:
log [a b c d]

-- logs `b c ["d", "e", "f"]`:
log [x y rest]
\end{lstlisting}

\subsection{\texttt{match} primitive}\label{sub:match}
The above examples show pattern matching used in function definitions and for destructuring values by binding their components to identifiers. There is also the \texttt{match} primitive, which can serve the role of a \texttt{switch} statement from C-like languages. It is however much more powerful, as any complex values supported by the pattern matching system can be matched, including lists. This allows switching on multiple values and in any combination.

The \texttt{match} primitive's first argument is a value to match and all
subsequent arguments are two-element lists, where the first element is the
pattern to match and the second is the expression to evaluate in case of a
match. The primitive tries the matches in order and only evaluates the
expression related to the first successful match. The subsequent matches are not evaluated.

Here are example uses for \texttt{match}:
\begin{lstlisting}
bind [state '|game-on]

-- will execute the `play` procedure:
match [state
    $['|game-on play!]
    $['|game-paused display-pause-menu!]
    $['|game-screenshot capture-screenshot!]
]

-- ...

-- note: . is the access operator 
-- .[a b c] is equivalent to a.b.c in other languages
bind [$[x y] .[player postion]]

-- we can easily replace complex conditions:
match [$[x x y y]
    $[
        $[>|0 <|screen-width >|0 <|screen-height]
        log|'[player visible]
    ]
    $[_ log|'[player not visible]]
]
\end{lstlisting}

\section{Rest parameters and spread operator}\label{sub:rest}
Another syntax extension that I introduced involves two additional special
bracketing characters: \texttt{\{} and \texttt{\}}, which serve several
purposes:
\begin{itemize}
    \item If used in function definitions, they indicate that a function or macro is variadic -- it accepts a variable number of arguments\cite{vararg_wikipedia}.
    
    If a function is invoked with an equal or greater number of arguments than stated in its definition and the last argument's name in this definition is specified between \texttt{\{} and \texttt{\}} then any extraneous arguments are available in the function's body in a list with the name that was specified inside the curly braces. The order of arguments is preserved. For example:
\begin{lstlisting}
bind [variadic-function of [a b {args}
    log [a b args]
]]

-- logs `1 2 [3, 4, 5, 6]`:
variadic-function[1 2 3 4 5 6]
\end{lstlisting}
    
    This is essentially the same as the ``rest parameters'' mechanism known from Lisp\cite[Section~12.2.3]{emacs_lisp_reference}, recently also adopted in JavaScript (as of the ECMAScript 2015 standard\cite{mdn_rest}).
    
    \item The above extends beyond function definitions. It works in any place, where pattern matching works:
\begin{lstlisting}
bind [$[a b {rest}] $['|a '|b '|c '|d '|e]]

-- logs `["c", "d", "e"]`:
log [rest]
\end{lstlisting}
    
    This enables non-exact matching. If only the first few elements of a list are important and a list with variable number of elements is acceptable as a match, the extra elements can be dropped by using this syntax.
    
    \item If used outside pattern matching, curly braces act as an universal list splicing and flattening operator. If an argument is given to a function surrounded by curly braces and this argument is a list then it is treated as if every individual element of that list was provided in its place.
    
    %Moreover, if such an element is itself a list, it is also expanded in this way. But this expansion is not recursive, so it does not expand further than one level of nesting.
    
    If an argument in curly braces is not a list, then curly braces behave like the identity operator and return it unchanged.
    
    There can be multiple arguments inside one pair of curly braces or multiple curly-braced arguments given to a function. All of these arguments will be expanded in the way described.
    
    For example:
\begin{lstlisting}
bind [f of [a b c d e f log [a b c d e f]]]
bind [args $[8 7 6]]

-- logs `9 8 7 6 5 4`:
f[9 {args} {$[5 4]}]

-- or alternatively,
-- surrounding all arguments with curly braces
-- logs `9 8 7 6 5 4`:
f[{9 args $[5 4]}]

-- curly braces can surround any argument
-- or any sequence of arguments,
-- regardless of position in the invocation list;
-- logs `9 8 7 6 [5, 4]`:
f[{9 args} $[5 4]]
\end{lstlisting}

    This works similarly to the spread operator from ECMAScript 2015\cite{mdn_spread} or the splicing syntax \texttt{,@} used in Lisp's backquotes\cite[Section~2.4.6]{common_lisp_hyperspec}, \cite[Section~9.4]{emacs_lisp_reference}, but is much more flexible. It can be used in every function or macro invocation, not just in backquotes. Also, if there is more that one list-argument that should be spliced, they can be grouped together inside curly braces and do not have to be individually ``tagged''.
     
    Curly braces can also be used as a nicer syntax for the fundamental function \texttt{apply}:
    \begin{lstlisting}
    bind [numbers $[1 2 3 4 5]]
    
    -- evaluates to 15:
    apply [sum numbers]
    
    -- also evaluates to 15:
    sum[{numbers}]
    \end{lstlisting}

    \item They also serve as string interpolation notation. When a string is evaluated, all expressions surrounded by \texttt{\{} and \texttt{\}} that appear inside this string are evaluated and spliced into its value before the value is returned. 
    
    For example:
\begin{lstlisting}
bind [name '|Bill]

-- logs `Hello, Bill.`:
log ['[Hello, {name}.]]
\end{lstlisting}
    
    This gives us a very convenient notation for string
    interpolation, similar to e.g. template literals in
    JavaScript\cite{mdn_template_strings}.
    
    To escape curly braces inside a string we can double them or use the escape character \texttt{\textbackslash}:
\begin{lstlisting}
-- logs `Hello, {name}.`:
log ['[Hello, {{name}}.]]

-- also logs `Hello, {name}.`:
log ['[Hello, \{name\}.]]
\end{lstlisting}
    
    There is also a special type of string -- an HTML string, where interpolation notation is the reversed -- double braces cause substitution, single braces do nothing:
\begin{lstlisting}
bind [name '|Bill]

-- logs `<h1>Hello, Bill.</h1>`:
log [html'[<h1>Hello, {{name}}.</h1>]]

-- logs `<h1>Hello, {name}.</h1>`:
log [html'[<h1>Hello, {name}.</h1>]]
\end{lstlisting}
    
    This is to enable embedding CSS and JavaScript code inside those strings,
    without having to constantly escape brace characters.
    
    \item Related to the above point, curly braces are used in \texttt{code'} strings that are returned by macros. They work similarly to curly braces in strings, except that the substituted values should be unevaluated expressions (syntax tree nodes). Also, code strings are never interpreted as streams of characters, and are always stored as syntax trees.
    
    This use of curly braces is very similar to Lisp's unquote syntax (\texttt{,})\cite[Section~1.3.8]{racket_reference}.
    
    The next section (\ref{sec:mac}) provides examples and explanation of macros in Dual.
\end{itemize}

\section{Just-in-time macros}\label{sec:mac}
The experimental approach to Dual's design gave rise to a very interesting feature, which could be described as first-class just-in-time expanded macros.

Macros in Lisp-like languages are different than the macros provided by the C preprocessor or similar macro systems. They are much more powerful\cite{c2_macros}.

Essentially, macros are a way to transform code from one (usually much terser) form to another. They can extend the language's syntax, create new syntactical constructs or \acrlong{dsl}s (\acrshort{dsl}s)\cite[Chapter~3]{lol_book}.

Lisp-like macros are integrated with the language and operate on its code or, more precisely, syntax trees\footnote{For brevity I will sometimes use the term ``code'' when I mean a syntax tree.}. Such a macro can be described as a function that takes code as arguments and returns code as a result. This code is then expanded into the syntax tree, replacing the macro. A macro can perform arbitrary computation while it is evaluated, just like a function. Macros are written in the same language as the code they transform.

\subsection{First-class}
Unlike traditional Lisp macros, in Dual macros are first-class, because they are treated like any other value.

In order to support first-class runtime macros, a Lisp interpreter can be
modified as follows\cite{macros}\footnote{Recall a brief description of an implementation of a Lisp interpreter from Section \ref{sec:lisp}.}:
\begin{itemize}
    \item Primitives are moved into the top-level environment\footnote{The top-level environment contains the basic functions and values that are available to every program.}. They thus are no longer treated as special case by the \texttt{eval} function.
    \item A new primitive, \texttt{macro} is added, which is essentially
    equivalent to \texttt{lambda}, except that it produces macro values
    instead of function values.
    \item The \texttt{apply} function is now responsible for checking the
    type of an expression's operator, which can be a \texttt{primitive}, a
    \texttt{macro} or a normal expression. This determines whether the
    arguments should be evaluated before application.
\end{itemize}

This results in a simpler, more uniform and at the same time more powerful
interpreter. A major advantage is that:
\begin{quote}
Because of their first-class nature, first-class macros make it easy to add or
simulate any degree of laziness\cite{macros}.
\end{quote}

A macro in Dual is defined with the \texttt{macro} primitive and bound to a name with the \texttt{bind} primitive:
\begin{lstlisting}
-- defines an `unless` macro,
-- which works like the `if` primitive,
-- except that the provided condition is negated
bind [unless macro [condition body alternative
    code'[if [not[{condition}] {body} {alternative}]]
]]

bind [a 100]

-- will log "a greater than 3":
unless [>[a 3]
    log|'[a less than or equal to 3]
    log|'[a greater than 3]
]
\end{lstlisting}

Because a macro is a first-class value, there is no need for a special primitive for defining macros, such as \texttt{defmacro} in Lisp\cite[Section~3.8, Macro DEFMACRO]{common_lisp_hyperspec}.

\subsection{Just-in-time}
Macros in Dual are just-in-time expanded, because the expansion happens at runtime, when a macro is encountered and evaluated by the interpreter. There is no separate macro-expansion time.

For simple macros the expansion works as follows:
\begin{itemize}
    \item A macro invocation is encountered by the interpreter.
    \item It is expanded into code by evaluating it.
    \item The node in the EST containing the macro invocation is permanently replaced by the expanded expression.
    \item The expanded expression is evaluated and its value is returned as the value of the invocation.
    \item Next time when the interpreter arrives at the same point in the EST, the macro will already be replaced by the expanded expression. Thus, the cost of macro-expansion is one-time.
\end{itemize}

Macros in Dual can also return other macro values. If a macro returns a macro value instead of code, this value is evaluated. If, in turn, the result of this evaluation is another macro value, this one is evaluated as well, and so on, until a code value is returned. It then is expanded as described above.

This feature nicely composes with Dual's variation of Lisp's syntax in terms readability, particularly by reducing the amount of adjacent closing brackets in the source code and introducing blocks without the need for explicit use of the \texttt{do} primitive.

As an example. the below listing presents a macro named \texttt{if*}, which defines a slightly different syntax for the \texttt{if} primitive. This syntax wraps the condition, consequent and alternative parts of the \texttt{if} in separate blocks delimited by \texttt{[]}. The condition is required to be an infix expression in the form \texttt{a operator b}. The consequent and alternative blocks take care of wrapping all expressions within them in \texttt{do} blocks. This makes it more convenient and less error-prone to write complex \texttt{if} expressions:
\begin{lstlisting}
-- defines the `if*` macro
-- it returns a macro, which returns a macro,
-- which returns another macro
-- arguments of each of these macros
-- are then spliced in the appropriate places
-- in the code that creates the resulting `if` expression:
bind [if* macro [a op b
    macro [{then}
        macro [{else}
            code'[if [apply[{op} {a} {b}] do[{then}] do[{else}]]]
        ]
    ]
]]

-- the macro is used as follows: 
if* [a < b][
    log ['[a is less than b]]
    a
][
    log ['[b is less than or equal to a]]
    b
]

-- the above expands to:
if [<[a b] do [
    log ['[a is less than b]]
    a
] do [
    log ['[b is less than or equal to a]]
    b
]]
\end{lstlisting}

Note that the macro gets rid of the explicit \texttt{do} expressions. It essentially defines a new language construct, which has the following template:
\begin{lstlisting}
if* [--[condition: ] <value-1> <comparison-operator> <value-2>][
    -- consequent block:
    <expression-1>
    <expression-2>
    -- ...
    <expression-n>
][
    -- alternative block:
    <expression-1>
    <expression-2>
    -- ...
    <expression-n>
]
\end{lstlisting}

\subsection{In combination with \texttt{|} and \texttt{!}}\label{subsub:macros}
The combination of the macro system and the syntax sugar for zero and single argument functions (\texttt{|} and \texttt{!}) helps reduce the amount of bracketing characters even further.

For example, if we define a \texttt{match*} and \texttt{of*} macros as follows:
\begin{lstlisting}
bind [match* macro [{args}
	macro [op
		code'[apply [{op args}]]
]]

bind [of* macro [{args}
    macro [{body}
        macro [alternative
            code'[of~ [{args} do[{body}] {alternative}]]
        ]
    ]
]]
\end{lstlisting}

Then the following expression:
\begin{lstlisting}
bind [x 99]

-- will log "x is greater than one":
match*  [x]
| of* [<|0] [log|'[x is negative]]
| of*   [0] [log|'[x is zero]]
| of*   [1] [log|'[x is one]]
| log|'[x is greater than one]
\end{lstlisting}

Would be translated into the following:
\begin{lstlisting}
bind [x 99]

-- will log "x is greater than one":
apply [
    of~ [<|0 log|'[x is negative]
        of~ [0 log|'[x is zero]
            of~ [1 log|'[x is one]
                log|'[x is greater than one]
            ]
        ]
    ]
    x
]
\end{lstlisting}

Notice that the \texttt{match*} macro does not use or need the native \texttt{match} construct at all.

The resulting syntax is somewhat similar to ML-style\cite[Section~Algebraic datatypes and pattern matching]{standard_ml_wikipedia} languages. And yet it there is no complex grammar that defines this syntax. It is handled with a very simple parser.

This shows that a few simple, but general syntax rules and a powerful macro system, can be a very flexible tool for extending syntax.

%TODO: modules