\chapter{Development environment}\label{chap:editor}

\section{Overview}
A folder is considered a project, similarly to modern code editors, such as Brackets or Visual Studio Code.

The current version of the development environment is intended to be used offline, on user's machine. Nevertheless it is designed so that it could be easily transformed into an online system.

I decided to implement the system with minimal dependencies, so it can be easily installed and so I can achieve a greater level of integration by having more control over every part.

The only required dependency for the basic functionality of the prototype to work (which is the editor) is a web browser and the CodeMirror library. An additional dependency is the Node.js environment.



The goal is to build an online \acrlong{ide} IDE, similar to Codeanywhere\footnote{\url{https://codeanywhere.com/}} or Cloud9\footnote{\url{https://c9.io/}}, works offline as well.

The language's development environment is implemented as a web application. It consists of three parts:
\begin{itemize}
    \item The server part, implemented in JavaScript on top of Node.js. This part's functions is mainly to enable access to user's file system, so any local folder can be opened as a project -- modern web browsers restrict access to the local file system, because of security reasons. The server part also handles persisting changes to files and configuration.
    \item The project manager part, which communicates directly with the server part. The connection is maintained over a WebSocket\footnote{\url{https://developer.mozilla.org/pl/docs/WebSockets}}. This part provides access to user's file system via a custom folder selection interface. Basic configuration of server communication, such as changing the address and ports is also possible. Once a project is selected, the user may open it in the editor part.
    \item The editor part, which is the main component and can function as a stand-alone application. It can communicate with the server indirectly, through the \texttt{localStorage} mechanism\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage}}.
\end{itemize}

The project manager and the editor, which can be considered the front-end parts of the system are designed to be a \acrlong{spa}\footnote{\url{https://en.wikipedia.org/wiki/Single-page_application}}. The project manager exchanges JSON messages with the server through a WebSocket. This is used for updating the view with dynamic data. In order to facilitate the manipulation of the HTML structure of the page, which is the main application's view, I implemented a very simple web application framework, which binds the data from the server with the data on the client and the \acrlong{dom}\footnote{\url{http://eloquentjavascript.net/13_dom.html}}.

\begin{figure}[h!]
\centering
\includegraphics[width=0.9\textwidth]{editor}
\caption{The editor}
\label{fig:editor}
\end{figure}

Figure \ref{fig:editor} shows an overview of the editor prototype's window. The basic layout is modeled after the aforementioned code editors. At the top of the window is the menu bar, below a global search input (not implemented in the prototype). The left panel contains basic controls for selecting examples, invoking the parser and interpreter, toggling application view and adjusting the scale of the visual representation.

The following options are implemented in the prototype:
\begin{itemize}
    \item Available from the menu bar:
    \begin{itemize}
        \item File->Save, which saves the current content of the text editor to a file named \texttt{save.dual} in editor's root directory. This only works if the server-side part of the environment is running. Otherwise the source will be saved only to browser's internal storage.
        \item In the Edit menu: Undo, Redo, Cut, Copy, Paste and Select All options are supported. Note that by default web browsers restrict the access to the user's clipboard, so for Copy and Paste the standard key shortcuts should be used (Ctrl-C, Ctrl-V). All other conventional keyboard shortcuts are also supported, thanks to the CodeMirror library.
    \end{itemize}
    \item Available from the left panel:
    \begin{itemize}
        \item The options in the Examples submenu cause a corresponding source file to be loaded into the editor. This is for demonstration for the purposes of this thesis.
        \item The Options submenu allows the user to invoke the parser and the interpreter separately or in combination as well as toggling between the ``page'' (also known as ``application'') and visual editor views. The application view contains an embedded web page (iframe), which can be manipulated by a Dual application. This is used to display the game view in the Pac-Man clone example.
        \item The Visual scale submenu changes the size of the blocks in the visual editor. This demonstrates how manipulating one CSS property influences the rendering of the visual representation.
    \end{itemize}
\end{itemize}

Some options have descriptive captions available that appear when the mouse cursor hovers over them.

\section{Text editor}
The text editor is built on top of the CodeMirror framework\footnote{\url{https://codemirror.net/}}. It was integrated with the editor in the following way:
\begin{itemize}
    \item A custom syntax highlighting mode for Dual was defined.
    % crucial:
    \item If a position of the text cursor in or the contents of the source change, a fragment of text corresponding to the appropriate \acrshort{est} node is highlighted. Also the corresponding subtree in the visual editor is highlighted. This works also in the other direction -- when a node in the visual editor is selected, it is highlighted along with the corresponding text fragment. This demonstrates the core functionality of the system: it is ``aware'' at all times of currently focused meaningful part of the code, corresponding to an \acrshort{est} node. This is reflected in every representation that is associated with the EST.

\end{itemize}
A naive implementation of 

Because every node in the EST is linked in both directions with a corresponding abstract element in a representation, any change to the element can be reflected in the node and, through the EST, in all other associated representations. This makes the system accurate and fast, as every change happens in an isolated context, which doesn't have to be reestablished every time a modification is made.

We can distinguish three representations used by the system:
\begin{enumerate}
    \item The EST, which is the master representation of the program.
    \item The fragments of text corresponding to EST nodes in the text representation are tracked by CodeMirror's TextMarker objects. These facilitate tracking and propagating any changes to and from this representation, as well as highlighting.
    \item The visual representation, which is implemented in terms of pure HTML tables fully styled with CSS. This allows for easy and complete customization of the representation.
\end{enumerate}

\begin{figure}[h!]
\centering
\includegraphics[width=0.9\textwidth]{editor-menu}
\caption{Visual editor's context menu}
\label{fig:editor-menu}
\end{figure}

In case of the visual representation this is implemented in a rather straightforward way: every EST node has a corresponding set of \acrshort{dom} nodes. Thanks to this, we can track any actions performed on the DOM through the standard browser-implemented interface. This is solved in the prototype by attaching \texttt{click} event handlers to relevant nodes. Such an event triggers the following:
\begin{itemize}
    \item A corresponding EST node is ``focused'' by the system. 
    \item A context menu appears similar to that depicted in \ref{fig:editor-menu}. This menu has basic options for editing the visual nodes: Replace, Add and Remove. These perform their corresponding action on the currently focused node and propagate it to all representations. The Remove option simply removes the selected node and its subtree from the DOM, the EST, as well as the associated text fragment. Add and Replace make use of the small text-editor area next to the context menu. It contains a list of possible names of nodes to be inserted in case the user wants to  a node. Selecting any of the names causes a template for the new node (in the form of an editable code snippet) to be inserted into the text-editor area. Such a template can be quickly adjusted by the user before inserting. The user may also type in raw code into the text box, without selecting any templates. After entering the code and selecting the appropriate option, the text is parsed, transformed into TextMarker, EST and DOM representations. Then all the versions of the fragment are inserted in appropriate places.
\end{itemize}

The list of possible nodes displayed along with the context menu is implemented in terms of a simple autocomplete functionality on top of CodeMirror. Every item in the autocomplete list is associated with a fragment of code, which is basically a signature of the corresponding function. User-defined functions could be easily automatically added to this list by extracting their signatures from definitions. Autocompletion should also be made context-sensitive, similarly to modern code editors.

The templates could also be selected by the user from a visual library of puzzle pieces, like the one in Scratch (Fig. \ref{fig:scratch}).
\begin{figure}[h!]
\centering
\includegraphics[width=0.9\textwidth]{scratch}
\caption{MIT Scratch programming language editor\footnote{Screenshot from  \url{
http://mypad.northampton.ac.uk/12406702/files/2013/05/Screen-Shot-2013-05-02-at-23.19.19-1s0qp26.png}}}
\label{fig:scratch}
\end{figure}

The templates prepared for the prototype use 

Saving own templates

Possible improvements and enhancments to the visual editor:
Support for more ways of manipulating the DOM representation, such as drag and drop.

Interactive visualisation of the syntax tree.


\section{Visual editor}
\subsection{The visual representation}
The fact that the visual representation is composed purely out of HTML and CSS 

Fully customisable with CSS

\subsubsection{Design}
Many iterations:

\begin{figure}[h!]
\centering
\includegraphics[width=0.9\textwidth]{designs_01234}
\caption{}
\label{fig:designs_01234}
\end{figure}


\begin{figure}[h!]
\centering
\includegraphics[width=0.9\textwidth]{design_3}
\caption{This design has the interesting property of visually illustrating the program flow with arrows.}
\label{fig:design_3}
\end{figure}


\begin{figure}[h!]
\centering
\includegraphics[width=0.9\textwidth]{design_4}
\caption{}
\label{fig:design_4}
\end{figure}

Not my final form.

A good design is not made overnight.

Smalltalk was perfected over 10 years.

Improvements:
icons, graphic controls
Specialized controls for editing different types of values
Some values have a very natural visual representation:
colors, perhaps vectors


%I considered using AngularJS\footnote{\url{https://angular.io/}}, but it would be an additional dependency .

Describe how the representations are \textit{dynamically} mapped into each other. 

angular
data binding

simple syntax can be easily mapped into a visual, tree-like representation:
basically we visualise the EST, with additional visual cues, widgets, etc. for language primitives, different datatypes, and other distinguishable elements

compare to unreal engine:
see chapter 7\ref{chap:comparison}

the interface is somewhat cumbersome, but allows for assembling any code that can be assembled with text
rapid editing: replacing any subtree

\section{Performance}

Inefficient -- unnecessary amount of DOM nodes is kept

It could be optimized similarly to CodeMirror or other web-based text editors or applications. That is, only a visible portion (plus a margin, which allows for fast scrolling) of the code is rendered as DOM nodes at any time. The scrollbar is virtual and controlled by the editor rather than the browser.

Text editors like CodeMirror use similar amount of DOM nodes [[]], but thanks to these optimizations are able to handle megabyte-sized\footnote{\url{http://codemirror.net/doc/internals.html#approach}} text files and are used in many real-world applications\footnote{\url{http://codemirror.net/doc/realworld.html}}, which includes being a built-in editor in developer tools in major web browsers.

Another source of inefficiency is that parsing is done twice -- once by Dual's parser and once by CodeMirror's system, which are incompatibile.
A solution to that would be to implement a custom text editor or extend/modify CodeMirror to work with Dual's parser.

% rendering text onto canvas?